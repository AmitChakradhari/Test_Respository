class Solution {
    func findKthLargest(_ nums: [Int], _ k: Int) -> Int {
        let heap = MaxHeap()
        for num in nums {
            heap.insert(val: num)
        }
        var largest: Int = Int.min
        for i in 1...k {
            largest = heap.popMax() ?? largest
        }
        return largest
    }

/// Main function
    final class MaxHeap {
        var heap: [Int] = []

        func insert(val: Int) {
            heap.append(val)
            heapifyUp(idx: heap.count - 1)
            //print("insert: \(heap)")
        }

        func popMax() -> Int? {
            guard !heap.isEmpty else { return nil }
            let max = heap.first
            (heap[0], heap[heap.count - 1]) = (heap[heap.count - 1], heap[0])
            heap.removeLast()
            if !heap.isEmpty {
                heapifyDown(idx: 0)
            }
            //print("popMax: \(max ?? -1) \(heap)")
            return max
        }

        func parentIndex(idx: Int) -> Int {
            (idx-1)/2
        }

        func leftIndex(idx: Int) -> Int {
            (2*idx) + 1
        }

        func rightIndex(idx: Int) -> Int {
            (2*idx) + 2
        }

        func hasParent(idx: Int) -> Bool {
            Double((idx-1))/2 >= 0
        }

        func leftChild(idx: Int) -> Int? {
            let leftIndex = leftIndex(idx: idx)
            if leftIndex < heap.count {
                // has left child
                return heap[leftIndex]
            } else {
                return nil
            }
        }

        func rightChild(idx: Int) -> Int? {
            let rightIndex = rightIndex(idx: idx)
            if rightIndex < heap.count {
                // has left child
                return heap[rightIndex]
            } else {
                return nil
            }
        }

        func heapifyUp(idx: Int) {
            var currentIdx = idx

            while hasParent(idx: currentIdx) {
                let parentIdx = parentIndex(idx: currentIdx)
                if heap[currentIdx] > heap[parentIdx] {
                    // swap
                    var temp = heap[currentIdx]
                    heap[currentIdx] = heap[parentIdx]
                    heap[parentIdx] = temp
                    currentIdx = parentIdx
                } else {
                    break
                }
            }
        }

        func heapifyDown(idx: Int) {
            var currentIdx = idx
            var highestIdx = idx

            while true {
                //print("81: \(currentIdx)")
                if let leftChild = leftChild(idx: currentIdx),
                   heap[currentIdx] < leftChild {
                    highestIdx = leftIndex(idx: currentIdx)
                    //print("85: \(highestIdx)")
                }
                if let rightChild = rightChild(idx: currentIdx),
                   heap[highestIdx] < rightChild {
                    highestIdx = rightIndex(idx: currentIdx)
                    //print("90: \(highestIdx)")
                }

                if highestIdx != currentIdx {
                    // swap
                    var temp = heap[currentIdx]
                    heap[currentIdx] = heap[highestIdx]
                    heap[highestIdx] = temp
                    currentIdx = highestIdx
                } else {
                    //print("break")
                    break
                }
            }
        }
    }
}
