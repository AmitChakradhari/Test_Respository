/// Max Heap Solution
class Solution {
    func findKthLargest(_ nums: [Int], _ k: Int) -> Int {
        let heap = MaxHeap()
        for num in nums {
            heap.insert(val: num)
        }
        var largest: Int = Int.min
        for i in 1...k {
            largest = heap.popMax() ?? largest
        }
        return largest
    }

/// Main function
    final class MaxHeap {
        var heap: [Int] = []

        func insert(val: Int) {
            heap.append(val)
            heapifyUp(idx: heap.count - 1)
            //print("insert: \(heap)")
        }

        func popMax() -> Int? {
            guard !heap.isEmpty else { return nil }
            let max = heap.first
            (heap[0], heap[heap.count - 1]) = (heap[heap.count - 1], heap[0])
            heap.removeLast()
            if !heap.isEmpty {
                heapifyDown(idx: 0)
            }
            //print("popMax: \(max ?? -1) \(heap)")
            return max
        }

        func parentIndex(idx: Int) -> Int {
            (idx-1)/2
        }

        func leftIndex(idx: Int) -> Int {
            (2*idx) + 1
        }

        func rightIndex(idx: Int) -> Int {
            (2*idx) + 2
        }

        func hasParent(idx: Int) -> Bool {
            Double((idx-1))/2 >= 0
        }

        func leftChild(idx: Int) -> Int? {
            let leftIndex = leftIndex(idx: idx)
            if leftIndex < heap.count {
                // has left child
                return heap[leftIndex]
            } else {
                return nil
            }
        }

        func rightChild(idx: Int) -> Int? {
            let rightIndex = rightIndex(idx: idx)
            if rightIndex < heap.count {
                // has left child
                return heap[rightIndex]
            } else {
                return nil
            }
        }

        func heapifyUp(idx: Int) {
            var currentIdx = idx

            while hasParent(idx: currentIdx) {
                let parentIdx = parentIndex(idx: currentIdx)
                if heap[currentIdx] > heap[parentIdx] {
                    // swap
                    var temp = heap[currentIdx]
                    heap[currentIdx] = heap[parentIdx]
                    heap[parentIdx] = temp
                    currentIdx = parentIdx
                } else {
                    break
                }
            }
        }

        func heapifyDown(idx: Int) {
            var currentIdx = idx
            var highestIdx = idx

            while true {
                //print("81: \(currentIdx)")
                if let leftChild = leftChild(idx: currentIdx),
                   heap[currentIdx] < leftChild {
                    highestIdx = leftIndex(idx: currentIdx)
                    //print("85: \(highestIdx)")
                }
                if let rightChild = rightChild(idx: currentIdx),
                   heap[highestIdx] < rightChild {
                    highestIdx = rightIndex(idx: currentIdx)
                    //print("90: \(highestIdx)")
                }

                if highestIdx != currentIdx {
                    // swap
                    var temp = heap[currentIdx]
                    heap[currentIdx] = heap[highestIdx]
                    heap[highestIdx] = temp
                    currentIdx = highestIdx
                } else {
                    //print("break")
                    break
                }
            }
        }
    }
}


/// Quick Selection Solution
class Solution {
    func findKthLargest(_ nums: [Int], _ k: Int) -> Int {
        var a: [Int] = nums
        return findKth(a: &a, k: k)
    }

    func quickSelect(a: inout [Int], i: Int, j: Int, k: Int, pivot: Int) -> Int {
        var tempI = i
        var tempJ = j
        while tempI <= pivot {
            if a[tempI] <= a[pivot] {
                tempJ += 1
                // swap
                var temp = a[tempI]
                a[tempI] = a[tempJ]
                a[tempJ] = temp
            }
            tempI += 1
        }
        return tempJ
    }


    func findKth(a: inout [Int], k: Int) -> Int {
        if a.isEmpty { return -1 }
        if k > a.count { return -1 }
        var i = 0, j = -1, pivot = a.count - 1
        var newSorted = quickSelect(a: &a, i: i, j: j, k: k, pivot: pivot)
        // if newPivot is the kth element ; return element
        // select from left or right subarray
        let kth = a.count - k
        while kth != newSorted {
            if kth > newSorted { // look right subarray
                i = newSorted + 1
                j = i - 1
            } else if kth < newSorted { // look left subarray
                j = i - 1
                pivot = newSorted - 1
            }
            newSorted = quickSelect(a: &a, i: i, j: j, k: k, pivot: pivot)
        }
        return a[newSorted]
    }
}
